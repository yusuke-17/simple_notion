# GitHub Copilot Instructions for Simple Notion Project

## プロジェクト概要
Simple NotionはNotionクローンアプリケーションで、Go（バックエンド）とReact/TypeScript（フロントエンド）を使用して構築されています。ブロックベースのエディターと階層構造の文書管理機能を提供します。

## 技術スタック
- **バックエンド**: Go, PostgreSQL, Air（開発時ホットリロード）
- **フロントエンド**: React, TypeScript, Vite, Tailwind CSS, Radix UI
- **インフラ**: Docker, Docker Compose
- **テスト**: Vitest（フロントエンド）, Go標準テスト（バックエンド）

## 基本原則

### 開発とコミュニケーション
- 常に日本語で分かりやすい言葉を選び、丁寧な表現を心がけます
- 初心者にも分かりやすく説明します。専門用語はできるだけ避け、必要な場合は簡単な説明を加えます
- 常に励ましの言葉を添えます。学習意欲が高まる工夫をします
- 質問の意図が理解できない場合は、その旨を伝えます

### 開発ツールの使用方針
- Copilotを使用する場合は、必ずSerena MCPを利用してプロジェクトの構造と規約を把握してからコード提案を行います
- コードの分析、検索、編集にはSerena MCPの機能を活用し、プロジェクト全体の整合性を保ちます

### プログラミングパターン
- 関数型および宣言型のプログラミングパターンを使用し、クラスの使用は避けます
- コードの重複を避け、反復とモジュール化を優先します
- 補助動詞（`isLoading`、`hasError`など）を用いた説明的な変数名を使用します
- ROROパターン（Receive an Object, Return an Object）を必要に応じて使用します

### 関数型プログラミング分離パターン（必須）
- **ビジネスロジックとView層の完全分離**: すべてのReactコンポーネントは、カスタムHooksによってビジネスロジックとUIレンダリングを明確に分離する
- **カスタムHooks設計**: 各コンポーネントに対応するカスタムHook（例：`useDocumentEditor`, `useRichTextEditor`, `useSidebar`）を作成し、状態管理、API通信、イベントハンドリングを集約する
- **純粋関数によるユーティリティ層**: 複数のHooksで共有される処理は純粋関数として`utils/`ディレクトリに分離し、テスタブルで再利用可能にする
- **コンポーネントのUI専用化**: Reactコンポーネントは「UIレンダリング専用」とし、JSX構造とユーザーインタラクションのみを担当する
- **依存注入パターン**: Hooksはpropsとしてコールバック関数を受け取り、親コンポーネントとの疎結合を維持する

### 開発プロセス
- 提案を行う際は、変更を個別のステップに分解し、各段階で小さなテストを提案して進行状況を確認します
- コードを書く前に、既存のコードを深くレビューし、動作を記述します
- ソリューションのホスト、管理、監視、保守方法を考慮し、運用上の懸念を強調します
- フィードバックに基づいてアプローチを調整し、提案がプロジェクトのニーズに合わせて進化するようにします

### セキュリティとデータ保護
- データを危険にさらしたり、新たな脆弱性をもたらさないように、あらゆる段階で確認します
- 潜在的なセキュリティリスクがある場合は、追加のレビューを行います

### 教育と支援
- コード例を示す際は、各行の目的を詳細なコメントで説明し、実行結果も示します
- 良いコーディングの習慣やベストプラクティスがあるなら、折りに触れアドバイスをします
- エラーメッセージは、エラーメッセージの意味を解説し、デバッグの手順を段階的に説明します
- 複雑な問題は、小さなステップに分割し一つずつ丁寧に解説します

### 実装時の説明責任
- 実装を行う際は、単に解決方法を示すだけでなく、「なぜこのアプローチを選択したのか」を必ず説明します
- 複数の解決方法がある場合は、それぞれの選択肢とその利点・欠点を比較して説明します
- 設計の判断理由（パフォーマンス、保守性、可読性、拡張性など）を明示します
- 実装の各ステップで、そのステップが必要な理由と期待される結果を説明します

## コーディング規約

### 全般的な原則
- **コメントとドキュメンテーション**: すべてのコメント、ドキュメント、テストケースの説明は日本語で記述する
- **変数・関数名**: 明確で説明的な変数名・関数名を使用（英語）
- RESTful API設計に従う
- Clean Architectureパターンを採用
- SOLID原則に従った設計を行います（単一責任、開放閉鎖、リスコフ置換、インターフェース分離、依存性逆転）

## バックエンドのコードスタイルと構造

### Go基本規約
- パッケージ名は小文字で記述
- ファイル名はsnake_caseで記述
- 公開関数/構造体はPascalCase、非公開はcamelCase
- エラーハンドリングでは適切なHTTPステータスコードとJSON形式のレスポンスを返す
- テーブル駆動テストを使用
- Clean Architectureパターンに従った設計

### プロジェクト構造
- `cmd/server/`: メインエントリーポイント
- `internal/handlers/`: HTTPハンドラー
- `internal/models/`: データモデル
- `internal/repository/`: データベースアクセス層
- `internal/middleware/`: ミドルウェア
- `migrations/`: データベースマイグレーション

### エラーハンドリング
- エラー処理とエッジケースを優先します
- エラー条件にはアーリーリターンを使用し、ガード句を実装して前提条件や無効な状態を早期に処理します
- 適切なエラーログとユーザーフレンドリーなエラーメッセージを実装します
- 予期しないエラーには適切なログ出力を実装します

## フォームとバリデーション

### 入力検証
- フロントエンド、バックエンド両方でバリデーションを実装
- 制御されたコンポーネントを使用したフォーム入力
- 適切なエラーメッセージの表示
- ユーザビリティを考慮した入力支援

### データの整合性
- スキーマ検証の実装
- 型安全性の確保
- サーバーサイドでの最終検証

## フロントエンドのコードスタイルと構造

### TypeScript/React基本規約
- 正確な例を用いて、簡潔で技術的なTypeScriptコードを記述します
- エクスポートされたコンポーネント、サブコンポーネント、ヘルパー、静的コンテンツ、型でファイルを構成します
- ディレクトリ名にはダッシュ付きの小文字を使用します（例：`components/auth-wizard`）
- コンポーネントは名前付きエクスポートを使用します。コンポーネント名にはケバブケースを使用します（例：`my-component.tsx`）
- 純粋な関数には `function` キーワードを使用します
- 単純なステートメントには簡潔な構文を使用します
- 宣言的なJSXを記述します
- 条件文では不要な中括弧を避け、1行文では中括弧を省略します
- セミコロンは省略します（ただし、文の曖昧さを避けるために必要な場合は使用します）
- 複雑なロジックには明確で簡潔なコメントを付けます（日本語）
- 関数やコンポーネントにはJSDocコメントを使用し、IDEのインテリセンスを向上させます（日本語）
- READMEファイルを常に最新の状態に保ちます

### ファイル構成とネーミング
- コンポーネント名はPascalCase（例: `DocumentEditor.tsx`）
- ユーティリティファイルはcamelCase（例: `utils.ts`）
- 関数コンポーネントを使用し、Hooksを活用
- Named Exportを推奨（default exportも併用可）
- インポート順序: 外部ライブラリ → 内部モジュール → 相対パス
- `@/`エイリアスを使用した絶対パス
- Tailwind CSSとRadix UIベースの共通コンポーネントを使用

### プロジェクト構造
- `src/components/`: Reactコンポーネント（UIレンダリング専用）
- `src/hooks/`: カスタムHooks（ビジネスロジック層）
- `src/utils/`: 純粋関数ユーティリティ（再利用可能なロジック）
- `src/stores/`: 状態管理
- `src/types/`: TypeScript型定義
- `src/tests/`: テストファイル

#### 関数型分離アーキテクチャ
```
src/
├── components/          # UI層（View専用）
│   ├── DocumentEditor.tsx      # UIレンダリングのみ
│   ├── RichTextEditor.tsx      # UIレンダリングのみ
│   └── Sidebar.tsx            # UIレンダリングのみ
├── hooks/              # ビジネスロジック層
│   ├── useDocumentEditor.ts    # 文書編集の統合ロジック
│   ├── useRichTextEditor.ts    # リッチテキストエディター管理
│   ├── useBlockManager.ts      # ブロック操作管理
│   ├── useAutoSave.ts         # 自動保存機能
│   └── useSidebar.ts          # サイドバー管理
└── utils/              # 純粋関数層
    ├── blockUtils.ts          # ブロック操作の純粋関数
    ├── documentUtils.ts       # 文書処理の純粋関数
    ├── editorUtils.ts         # エディター関連ヘルパー
    └── sidebarUtils.ts        # サイドバー用ユーティリティ
```

## UIとスタイリング

### デザインシステム
- コンポーネントとスタイリングには、Radix UI、Tailwind CSSを使用します
- Tailwind CSSでレスポンシブデザインを実装し、モバイルファーストのアプローチを採用します
- セマンティックなHTML要素を使用し、適切なARIA属性を実装し、キーボードナビゲーションをサポートします

### アクセシビリティ
- セマンティックなHTMLを使用
- 適切なARIA属性の実装
- キーボードナビゲーションのサポート
- スクリーンリーダーへの配慮

## 状態管理とデータフェッチ

### 状態管理戦略
- ローカル状態には `useState` を使用
- 複雑な状態ロジックには `useReducer` を検討
- グローバル状態が必要な場合は、ContextやZustandの使用を検討
- `use client`、`useEffect`、`useState`の使用を最小限にし、可能な限りサーバーサイドレンダリングの機能を優先します

### API通信
- fetch APIを使用したHTTP通信
- エラーハンドリングの適切な実装
- ローディング状態の管理
- データの型安全性を確保

### データベース規約
- テーブル名は複数形のsnake_case（例: `users`, `documents`, `blocks`）
- カラム名はsnake_case
- IDカラムは`id`、外部キーは`{table}_id`
- タイムスタンプは`created_at`, `updated_at`

## 開発時の注意事項

### Docker環境
- 開発時は`docker-compose.dev.yml`を使用
- フロントエンドポート: 5173
- バックエンドポート: 8080
- PostgreSQLポート: 5432

### API設計
- RESTful APIパターンに従う
- 認証が必要なエンドポイントにはJWTミドルウェアを適用
- エラーレスポンスは一貫したJSON形式で返す

## テストとQA

### フロントエンドテスト
- Testing Libraryを使用してユーザーの動作をテスト
- Vitestを使用した単体テスト
- 重要なユーザーフローには統合テストを実装
- テストファイルは`*.test.tsx`または`__tests__/*.tsx`
- **テストケースの説明とコメントは日本語で記述**

### バックエンドテスト
- テーブル駆動テストとモックを活用した単体テスト
- API統合テストの実装
- テストファイルは`*_test.go`
- モック使用時は適切な依存注入を実装
- **テストケースの説明とコメントは日本語で記述**

### 品質保証
- エラーハンドリングは必ず含める
- 型安全性の確保（TypeScriptの厳密な型付け）
- Propsには必ず型定義を付ける
- API通信時の型定義を`types/index.ts`に集約

## 開発プロセスと運用

### 開発環境管理
- 開発時は`docker-compose.dev.yml`を使用
- フロントエンドポート: 5173
- バックエンドポート: 8080
- PostgreSQLポート: 5432

### API設計とドキュメント
- RESTful APIパターンに従う
- 認証が必要なエンドポイントにはJWTミドルウェアを適用
- エラーレスポンスは一貫したJSON形式で返す
- API仕様書を常に最新の状態に保つ

### 運用上の考慮事項
- ソリューションのホスト、管理、監視、保守方法を考慮
- ログ出力戦略の実装
- ヘルスチェック機能の実装
- 適切なエラー追跡システムの導入

## セキュリティとデータ保護

### セキュリティ基本原則
- 認証トークンの適切な管理
- SQLインジェクション対策（プリペアドステートメント使用）
- XSS対策（適切なエスケープ処理）
- XSS攻撃を防ぐために、ユーザー入力をサニタイズします
- `dangerouslySetInnerHTML` は控えめに、サニタイズされたコンテンツでのみ使用します

### データ保護
- データを危険にさらしたり、新たな脆弱性をもたらさないように、あらゆる段階で確認します
- 潜在的なセキュリティリスクがある場合は、追加のレビューを行います
- パスワードやAPIキーをハードコーディングしない

## 最適化とパフォーマンス

### フロントエンド最適化
- React.memoやuseCallbackを適切に使用
- 大きなリストにはVirtualizationを検討
- クリティカルでないコンポーネントには動的ローディングを使用
- 画像は適切なフォーマットを使用し、サイズデータを含め、遅延ロードを実装

### バックエンド最適化
- データベースクエリは効率的に記述
- 適切なインデックスの使用
- N+1問題の回避
- キャッシュ戦略の実装

### 全般的な最適化
- グローバルスタイルの使用を最小限に抑え、モジュール化された、スコープされたスタイルを使用
- コード分割の実装
- バンドルサイズの最適化

## コード生成時の推奨事項
- Copilotを使用する場合は、必ずSerena MCPを利用してプロジェクトの構造と規約を把握してからコード提案を行います
- **関数型分離パターンの強制**: 新規コンポーネント作成時は必ずHooks（ビジネスロジック）とView（UIレンダリング）に分離する
- **純粋関数の優先**: 複数箇所で使用される処理は純粋関数としてutils/に実装する
- コードを修正する場合は、既存のテストコードを必ず確認し、修正に合わせてテストも更新します
- テストコードが存在しない場合は、機能追加・修正と同時にテストコードを必ず追加します
- 新しいコンポーネント作成時は以下を同時に生成:
  - コンポーネント（View層）: `src/components/{ComponentName}.tsx`
  - カスタムHook（ビジネスロジック層）: `src/hooks/use{ComponentName}.ts`
  - ユーティリティ（必要に応じて）: `src/utils/{featureName}Utils.ts`
  - テストファイル（各層に対応）
  - 型定義の追加
- APIハンドラー作成時は対応するテストケースも含める
- データベースマイグレーション追加時は適切なロールバック処理も記述
- エラーハンドリングは必ず含める
- 機能の実装や修正を行った場合は、関連するドキュメント（特にREADME.md）も合わせて更新します
- **すべてのコメントとドキュメントは日本語で記述する**

## テスト駆動開発の必須化

### テストファーストの原則
- 新機能の実装前には、まずテストケースを作成して期待する動作を定義します
- 既存コードの修正時は、修正前にテストケースで現在の動作を確認し、修正後もテストが通ることを確認します
- リファクタリング時は、既存のテストが全て通ることを保証してから行います

### テストカバレッジの要求
- 新規追加するすべての関数・コンポーネントにはテストを必須とします
- バグ修正時は、そのバグを再現するテストケースを作成してから修正します
- 重要なビジネスロジックには100%のテストカバレッジを目指します

## 禁止事項
- `any`型の使用は最小限に抑制
- 未使用のimportやvariableを残さない
- console.logはデバッグ目的以外で使用しない
- パスワードやAPIキーをハードコーディングしない
- テストコードなしでの機能追加・修正は禁止
- Serena MCPを使用せずにCopilotでコード提案を行うことは禁止
- **モノリシックコンポーネントの作成禁止**: ビジネスロジックとUIが混在したコンポーネントの作成は禁止
- **Hooks分離なしでの複雑なコンポーネント作成禁止**: 100行を超えるコンポーネントはHooks分離を必須とする

## ファイルパターン

### フロントエンド（関数型分離アーキテクチャ）
- React コンポーネント（View層）: `src/components/{ComponentName}.tsx`
- カスタムHooks（ビジネスロジック層）: `src/hooks/use{FeatureName}.ts`
- ユーティリティ関数（純粋関数層）: `src/utils/{featureName}Utils.ts`
- React テスト: `src/components/__tests__/{ComponentName}.test.tsx`
- Hooks テスト: `src/hooks/__tests__/use{FeatureName}.test.ts`
- Utils テスト: `src/utils/__tests__/{featureName}Utils.test.ts`
- 型定義: `src/types/index.ts`

### バックエンド
- Goハンドラー: `internal/handlers/{feature}.go`
- Goテスト: `internal/handlers/{feature}_test.go`
- Goモデル: `internal/models/{model}.go`
- SQLマイグレーション: `migrations/{number}_{description}.sql`
